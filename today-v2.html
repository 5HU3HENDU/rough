<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Today - Smart Journal</title>
    <meta name="description" content="A text-based smart todo app" />
    
    <!-- Stlite (Streamlit in the browser) Configuration -->
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.50.0/build/stlite.js"></script>
    
    <!-- Custom CSS -->
    <style>
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #f0f2f6;
        }
        header { visibility: hidden; }
        footer { visibility: hidden; }
        
        /* Make the textarea feel like a real notepad */
        .stTextArea textarea {
            font-size: 16px !important;
            line-height: 1.6 !important;
            min-height: 400px !important;
            border-radius: 8px;
        }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script>
      stlite.mount({
        requirements: ["pandas"],
        entrypoint: "today_app.py",
        files: {
          "today_app.py": `
import streamlit as st
import random
import re
from collections import Counter
from datetime import datetime, timedelta, date
import calendar as cal_module

# --- 1. SETUP & JS BRIDGE ---
st.set_page_config(page_title="Today", page_icon="üìù", layout="centered")

# Javascript bridge for LocalStorage
try:
    from js import window
    HAS_JS = True
except ImportError:
    HAS_JS = False

# --- 2. PERSISTENCE LOGIC ---

def init_storage():
    """
    Initialize session state from LocalStorage on first load.
    """
    if "notepad_content" not in st.session_state:
        # Default content
        initial_text = "Buy groceries on Saturday\\nMeeting with Team A on Monday\\nCall Mom today\\nFinish the report by 2025-11-20\\nGo to the Gym everyday\\nProjectX budget review"
        
        if HAS_JS:
            stored_data = window.localStorage.getItem("today_app_data")
            if stored_data:
                initial_text = stored_data
        
        st.session_state["notepad_content"] = initial_text

def save_to_storage():
    """
    Save the current widget value to LocalStorage.
    """
    current_text = st.session_state["notepad_widget"]
    # Update python state
    st.session_state["notepad_content"] = current_text
    
    # Update Browser Storage
    if HAS_JS:
        window.localStorage.setItem("today_app_data", current_text)
        return True
    return False

# Run initialization once
init_storage()

# --- 3. PARSING LOGIC (NLP) ---

def get_clean_tasks(raw_text):
    return [line.strip() for line in raw_text.split('\\n') if line.strip()]

def parse_dates(tasks):
    """
    Parses tasks to find:
    1. YYYY-MM-DD
    2. Keywords: today, tomorrow, everyday, weekend
    3. Weekdays: Monday, Tuesday, etc.
    """
    agenda = {}
    today = date.today()
    tomorrow = today + timedelta(days=1)
    
    # Regex patterns
    date_pattern = re.compile(r'\\d{4}-\\d{2}-\\d{2}')
    
    # Map day names to numbers (0=Monday, 6=Sunday)
    weekdays_map = {
        "monday": 0, "tuesday": 1, "wednesday": 2, "thursday": 3, 
        "friday": 4, "saturday": 5, "sunday": 6
    }

    for task in tasks:
        task_lower = task.lower()
        matched_date = None
        
        # 1. Check Specific Keywords
        if "today" in task_lower:
            matched_date = today
        elif "tomorrow" in task_lower:
            matched_date = tomorrow
        elif "everyday" in task_lower:
            matched_date = today # Treat as today for visibility
        elif "weekend" in task_lower:
             # Find next Saturday (5)
             days_ahead = 5 - today.weekday()
             if days_ahead < 0: days_ahead += 7
             matched_date = today + timedelta(days=days_ahead)
        
        # 2. Check Weekdays (Monday, Tuesday...)
        if not matched_date:
            for day_name, day_num in weekdays_map.items():
                # We use word boundaries \\b to avoid matching "part" in "party"
                if re.search(r'\\b' + day_name + r'\\b', task_lower):
                    current_day_num = today.weekday()
                    days_diff = day_num - current_day_num
                    
                    # Logic: 
                    # If days_diff < 0 (e.g. Today is Wed, looking for Mon), it's next week (+7)
                    # If days_diff == 0, it's Today
                    # If days_diff > 0, it's later this week
                    
                    if days_diff < 0:
                        days_diff += 7
                    
                    matched_date = today + timedelta(days=days_diff)
                    break # Stop checking other days if one found

        # 3. Check YYYY-MM-DD
        if not matched_date:
            match = date_pattern.search(task)
            if match:
                try:
                    matched_date = datetime.strptime(match.group(), '%Y-%m-%d').date()
                except:
                    pass
        
        # Add to agenda if date found
        if matched_date:
            if matched_date not in agenda:
                agenda[matched_date] = []
            agenda[matched_date].append(task)
            
    return agenda

def get_categories(tasks):
    STOP_WORDS = {
        'the', 'and', 'to', 'of', 'a', 'in', 'is', 'it', 'you', 'that', 'for', 
        'on', 'with', 'as', 'at', 'this', 'but', 'by', 'not', 'or', 'be', 'are',
        'from', 'an', 'so', 'if', 'my', 'all', 'about', 'go', 'do', 'get', 'me',
        'up', 'out', 'can', 'today', 'tomorrow', 'yesterday', 'everyday', 'date',
        'task', 'note', 'buy', 'finish', 'call', 'meeting', 'review', 'weekday', 'weekend',
        'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'
    }
    
    word_map = {}
    all_words = []
    
    for task in tasks:
        clean_task = re.sub(r'[^a-zA-Z0-9\\s]', '', task.lower())
        words = clean_task.split()
        seen_in_task = set()
        for word in words:
            if word not in STOP_WORDS and len(word) > 2 and not word.isdigit():
                if word not in seen_in_task:
                    all_words.append(word)
                    if word not in word_map:
                        word_map[word] = []
                    word_map[word].append(task)
                    seen_in_task.add(word)

    counts = Counter(all_words)
    sorted_cats = sorted(counts.items(), key=lambda x: (-x[1], x[0]))
    return [(word, count, word_map[word]) for word, count in sorted_cats if count > 0]

# --- 4. MAIN UI ---

st.title("Today")
tab_today, tab_notepad, tab_category, tab_calendar = st.tabs(["Today", "Notepad", "Categories", "Calendar"])

# --- TAB: NOTEPAD ---
with tab_notepad:
    st.caption("Type freely. Changes save automatically when you click away or press Ctrl+Enter.")
    
    # The Text Area
    # key="notepad_widget" binds this to session_state
    # on_change=save_to_storage calls the function when user triggers update
    val = st.text_area(
        "Notepad", 
        value=st.session_state["notepad_content"], 
        height=400, 
        key="notepad_widget",
        on_change=save_to_storage,
        label_visibility="collapsed"
    )
    
    # Little status indicator
    if save_to_storage(): # We call this here to ensure save on simple re-runs too
        st.toast("Saved to browser!", icon="üíæ")


# Process Data
tasks = get_clean_tasks(st.session_state["notepad_content"])
agenda_data = parse_dates(tasks)

# --- TAB: TODAY ---
with tab_today:
    today_date = date.today()
    st.header(f"{today_date.strftime('%A, %B %d')}")
    
    todays_specific_tasks = agenda_data.get(today_date, [])
    
    st.subheader("Tasks for Today")
    
    if not tasks:
        st.info("Go to Notepad and add some tasks!")
    else:
        # Priority 1: Explicit dates/keywords
        if todays_specific_tasks:
            for t in todays_specific_tasks:
                st.success(f"üìç {t}")
        
        # Priority 2: Random suggestions (excluding Priority 1)
        remaining_tasks = [t for t in tasks if t not in todays_specific_tasks]
        
        # Always show at least 3 items total if possible
        slots_filled = len(todays_specific_tasks)
        slots_needed = 3 - slots_filled
        
        if slots_needed > 0 and remaining_tasks:
            k = min(len(remaining_tasks), slots_needed)
            random_picks = random.sample(remaining_tasks, k)
            for pick in random_picks:
                st.warning(f"üé≤ {pick}")

        if not todays_specific_tasks and not remaining_tasks:
            st.success("Everything done!")

# --- TAB: CALENDAR ---
with tab_calendar:
    st.write("üìÖ Agenda View")
    
    if not agenda_data:
        st.info("Type days like 'Monday' or dates like '2025-01-01' in the notepad.")
    
    sorted_dates = sorted(agenda_data.keys())
    
    for d in sorted_dates:
        # Skip past dates for cleaner view? Optional. keeping them for history for now.
        is_today = d == date.today()
        
        date_str = d.strftime('%Y-%m-%d')
        day_name = d.strftime('%A')
        
        if is_today:
            st.markdown(f"#### üî¥ {day_name} (Today)")
        else:
            st.markdown(f"#### {day_name}, {date_str}")
            
        for t in agenda_data[d]:
            st.write(f"- {t}")
        st.divider()

# --- TAB: CATEGORIES ---
with tab_category:
    st.write("Context Analysis")
    categories = get_categories(tasks)
    
    if not categories:
        st.info("Add more detailed tasks to see categories.")
    
    for word, count, associated_tasks in categories:
        with st.expander(f"üìÇ **{word.capitalize()}** ({count})"):
            for t in associated_tasks:
                st.write(f"- {t}")
`
        }
      });
    </script>
  </body>
</html>


